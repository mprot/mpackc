package golang

import (
	"fmt"

	"github.com/mprot/mprotc/gen"
	"github.com/mprot/mprotc/schema"
)

// Options holds all the options for the Go language generator.
type Options struct {
	ScopedEnums bool // scope enumerators?
	UnwrapUnion bool // unwrap union types in struct fields?
}

// Generator represents a code generator for the Go programming language.
type Generator struct {
	cnst  constGenerator
	enum  enumGenerator
	strct structGenerator
	union unionGenerator
}

// NewGenerator creates a new Go code generator with the given options.
func NewGenerator(opts Options) *Generator {
	return &Generator{
		enum: enumGenerator{
			scoped: opts.ScopedEnums,
		},
		strct: structGenerator{
			unwrapUnion: opts.UnwrapUnion,
		},
	}
}

// Generate generates the Go code for the given schema and prints it to p.
func (g *Generator) Generate(w *gen.FileWriter, s *schema.Schema) {
	g.generate(w.Printer(".go"), s)
}

func (g *Generator) generate(p gen.Printer, s *schema.Schema) {
	p.Println(`// Code generated by mprotc.`)
	p.Println(`// Do not edit.`)
	p.Println()

	printDoc(p, s.Doc, "")
	p.Println(`package `, s.Package)
	p.Println()
	p.Println(`import (`)
	p.Println(`	"fmt"`)
	p.Println(`	"time"`)
	p.Println()
	p.Println(`	msgpack "github.com/mprot/msgpack-go"`)
	p.Println(`)`)
	p.Println()
	p.Println(`var _ = fmt.Errorf`)
	p.Println(`var _ time.Time`)
	p.Println(`var _ *msgpack.Writer`)

	for _, decl := range s.Decls {
		p.Println()

		switch decl := decl.(type) {
		case *schema.Const:
			g.cnst.Generate(p, decl)
		case *schema.Enum:
			g.enum.Generate(p, decl)
		case *schema.Struct:
			g.strct.Generate(p, decl)
		case *schema.Union:
			g.union.Generate(p, decl)
		default:
			panic(fmt.Sprintf("unsupported declaration type %T", decl))
		}
	}
}
