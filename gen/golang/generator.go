package golang

import (
	"fmt"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/mprot/mprotc/gen"
	"github.com/mprot/mprotc/schema"
)

// Options holds all the options for the Go language generator.
type Options struct {
	ImportRoot  string // root path of all schema imports
	ScopedEnums bool   // scope enumerators?
	UnwrapUnion bool   // unwrap union types in struct fields?
}

// Generator represents a code generator for the Go programming language.
type Generator struct {
	importRoot string
	cnst       constGenerator
	enum       enumGenerator
	strct      structGenerator
	union      unionGenerator
}

// NewGenerator creates a new Go code generator with the given options.
func NewGenerator(opts Options) *Generator {
	return &Generator{
		importRoot: opts.ImportRoot,
		enum: enumGenerator{
			scoped: opts.ScopedEnums,
		},
		strct: structGenerator{
			unwrapUnion: opts.UnwrapUnion,
		},
	}
}

// Generate generates the Go code for the given schema and prints it to p.
func (g *Generator) Generate(w *gen.FileWriter, s schema.Schema) {
	for _, file := range s {
		g.generate(w.Printer(file.Name, ".go"), file)
	}
}

func (g *Generator) generate(p gen.Printer, f *schema.File) {
	imports := fileImports(f)

	p.Println(`// Code generated by mprotc.`)
	p.Println(`// Do not edit.`)
	p.Println()

	printDoc(p, f.Doc, "")
	p.Println(`package `, f.Package.Name)
	p.Println()
	p.Println(`import (`)
	p.Println(`	"fmt"`)
	p.Println(`	"time"`)
	p.Println()
	p.Println(`	msgpack "github.com/mprot/msgpack-go"`)
	if len(imports) != 0 {
		p.Println()
		for _, imp := range sortedImports(imports) {
			importPath := filepath.Dir(imp.Path)
			if filepath.Separator != '/' {
				importPath = strings.Replace(importPath, string(filepath.Separator), "/", -1)
			}
			importPath = path.Join(g.importRoot, importPath)
			p.Println(`	`, imp.Name, ` "`, importPath, `"`)
		}
	}
	p.Println(`)`)
	p.Println()
	p.Println(`var _ = fmt.Errorf`)
	p.Println(`var _ time.Time`)
	p.Println(`var _ *msgpack.Writer`)

	types := &typegen{imports: imports}
	for _, decl := range f.Decls {
		p.Println()

		switch decl := decl.(type) {
		case *schema.Const:
			g.cnst.Generate(p, decl)
		case *schema.Enum:
			g.enum.Generate(p, decl)
		case *schema.Struct:
			g.strct.Generate(p, decl, types)
		case *schema.Union:
			g.union.Generate(p, decl, types)
		default:
			panic(fmt.Sprintf("unsupported declaration type %T", decl))
		}
	}
}

func fileImports(f *schema.File) map[string]*schema.Import {
	fileDir := filepath.Dir(f.Name)
	imports := make(map[string]*schema.Import)
	for _, imp := range f.Imports {
		importDir := filepath.Dir(imp.Path)
		if importDir != fileDir {
			imports[imp.Name] = imp
		}
	}
	return imports
}

func sortedImports(imports map[string]*schema.Import) []*schema.Import {
	res := make([]*schema.Import, 0, len(imports))
	for _, imp := range imports {
		res = append(res, imp)
	}
	sort.Slice(res, func(i, j int) bool { return res[i].Path < res[j].Path })
	return res
}
