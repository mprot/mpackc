package js

import (
	"fmt"
	"sort"
	"strings"

	"github.com/tsne/mpackc/gen"
	"github.com/tsne/mpackc/schema"
)

// Generator represents a code generator for the JavaScript language.
type Generator struct {
	cnst  constGenerator
	enum  enumGenerator
	strct structGenerator
	union unionGenerator
}

// NewGenerator creates a new JavaScript code generator with the given options.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates the JavaScript code for the given schema and prints it to p.
func (g *Generator) Generate(p *gen.Printer, s *schema.Schema) {
	p.Println(`// Code generated by mpackc.`)
	p.Println(`// Do not edit.`)
	p.Println()

	if len(s.Doc) != 0 {
		printDoc(p, s.Doc, "")
		p.Println()
	}

	if imports := strings.Join(msgpackImports(s), ", "); len(imports) != 0 {
		p.Println(`import {`, imports, `} from "messagepack";`)
		p.Println()
	}

	for _, decl := range s.Decls {
		p.Println()

		switch decl := decl.(type) {
		case *schema.Const:
			g.cnst.Generate(p, decl)
		case *schema.Enum:
			g.enum.Generate(p, decl)
		case *schema.Struct:
			g.strct.Generate(p, decl)
		case *schema.Union:
			g.union.Generate(p, decl)
		default:
			panic(fmt.Sprintf("unsupported declaration type %T", decl))
		}
	}

	g.printCollectionTypes(p, s)
}

func (g *Generator) printCollectionTypes(p *gen.Printer, s *schema.Schema) {
	types := map[string]string{} // typename => type declaration
	iterTypes(s, func(t schema.Type) {
		switch t := t.(type) {
		case *schema.Array:
			types[msgpackType(t)] = fmt.Sprintf("TypedArr(%s)", msgpackType(t.Value))
		case *schema.Map:
			types[msgpackType(t)] = fmt.Sprintf("TypedMap(%s, %s)", msgpackType(t.Key), msgpackType(t.Value))
		}
	})

	if len(types) == 0 {
		return
	}

	typedefs := make([]string, 0, len(types))
	for name, decl := range types {
		typedefs = append(typedefs, fmt.Sprintf("const %s = %s;", name, decl))
	}
	sort.Strings(typedefs)

	p.Println()
	p.Println(`// Required collection types.`)
	for _, typedef := range typedefs {
		p.Println(typedef)
	}
}

func msgpackImports(s *schema.Schema) []string {
	imports := map[string]struct{}{}
	iterTypes(s, func(t schema.Type) {
		if defined, ok := t.(*schema.DefinedType); ok {
			if _, isEnum := defined.Decl.(*schema.Enum); isEnum {
				imports["Int"] = struct{}{}
			}
		} else {
			imports[msgpackImport(t)] = struct{}{}
		}
	})

	res := make([]string, 0, len(imports))
	for imp := range imports {
		if imp != "" {
			res = append(res, imp)
		}
	}
	sort.Strings(res)
	return res
}
