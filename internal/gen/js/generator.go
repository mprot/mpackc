package js

import (
	"fmt"
	"sort"
	"strings"

	"github.com/mprot/mprotc/internal/gen"
	"github.com/mprot/mprotc/internal/schema"
)

// Options holds all the options for the JavaScript language generator.
type Options struct {
	TypeDecls bool // generate type declarations?
}

// Generator represents a code generator for the JavaScript language.
type Generator struct {
	cnst  constGenerator
	enum  enumGenerator
	strct structGenerator
	union unionGenerator

	typeDecls bool
}

// NewGenerator creates a new JavaScript code generator with the given options.
func NewGenerator(opts Options) *Generator {
	return &Generator{
		enum: enumGenerator{
			typeDecls: opts.TypeDecls,
		},
		typeDecls: opts.TypeDecls,
	}
}

// Generate generates the JavaScript code for the given schema and prints it to p.
func (g *Generator) Generate(w *gen.FileWriter, s schema.Schema) {
	for _, file := range s {
		g.generate(w.Printer(file.Name, ".js"), file)
		if g.typeDecls {
			g.generateTypeDecls(w.Printer(file.Name, ".d.ts"), file)
		}
	}
}

func (g *Generator) generate(p gen.Printer, f *schema.File) {
	codec := newCodec("__codec")

	g.printPreamble(p)
	if len(f.Doc) != 0 {
		p.Println()
		printDoc(p, f.Doc, "")
	}
	p.Println()
	g.printImports(p, msgpackImports(f))
	p.Println()
	g.printDeclarations(p, f, codec)
	p.Println()
	g.printCollectionTypes(p, f)
	if codec.Size() != 0 {
		p.Println()
		g.printCodec(p, codec)
	}
}

func (g *Generator) generateTypeDecls(p gen.Printer, f *schema.File) {
	g.printPreamble(p)
	g.printImports(p, typescriptImports(f))

	for _, decl := range f.Decls {
		switch decl := decl.(type) {
		case *schema.Const:
			continue
		case *schema.Enum:
			g.enum.GenerateTypeDecls(p, decl)
		case *schema.Struct:
			g.strct.GenerateTypeDecls(p, decl)
		case *schema.Union:
			g.union.GenerateTypeDecls(p, decl)
		default:
			panic(fmt.Sprintf("unsupported declaration type %T", decl))
		}

		p.Println()
	}
}

func (g *Generator) printPreamble(p gen.Printer) {
	p.Println(`// Code generated by mprotc.`)
	p.Println(`// Do not edit.`)
}

func (g *Generator) printImports(p gen.Printer, imports []string) {
	if imp := strings.Join(imports, ", "); imp != "" {
		p.Println(`import {`, imp, `} from "messagepack";`)
		p.Println()
	}
}

func (g *Generator) printDeclarations(p gen.Printer, f *schema.File, codec *codec) {
	for i, decl := range f.Decls {
		switch decl := decl.(type) {
		case *schema.Const:
			g.cnst.GenerateDecl(p, decl)
		case *schema.Enum:
			g.enum.GenerateDecl(p, decl)
		case *schema.Struct:
			g.strct.GenerateDecl(p, decl, codec.Context(decl))
		case *schema.Union:
			g.union.GenerateDecl(p, decl, codec.Context(decl))
		default:
			panic(fmt.Sprintf("unsupported declaration type %T", decl))
		}

		if i < len(f.Decls)-1 {
			p.Println()
		}
	}
}

func (g *Generator) printCodec(p gen.Printer, codec *codec) {
	p.Println(`const `, codec.Name(), ` = {`)

	for _, ctx := range codec.Contexts() {
		switch decl := ctx.Decl().(type) {
		case *schema.Struct:
			g.strct.GenerateCodec(gen.PrefixedPrinter(p, "\t"), decl, ctx)
		case *schema.Union:
			g.union.GenerateCodec(gen.PrefixedPrinter(p, "\t"), decl, ctx)
		}
	}

	p.Println(`	enc(ord, newEnc, buf, v) { (this[ord].enc = this[ord].enc || newEnc(this[ord]))(buf, v) },`)
	p.Println(`	dec(ord, newDec, buf) { return (this[ord].dec = this[ord].dec || newDec(this[ord]))(buf) },`)
	p.Println(`};`)
}

func (g *Generator) printCollectionTypes(p gen.Printer, f *schema.File) {
	types := map[string]string{} // typename => type declaration
	iterTypes(f, func(t schema.Type) {
		switch t := t.(type) {
		case *schema.Array:
			types[msgpackTypename(t)] = fmt.Sprintf("TypedArr(%s)", msgpackTypename(t.Value))
		case *schema.Map:
			types[msgpackTypename(t)] = fmt.Sprintf("TypedMap(%s, %s)", msgpackTypename(t.Key), msgpackTypename(t.Value))
		}
	})

	if len(types) == 0 {
		return
	}

	typedefs := make([]string, 0, len(types))
	for name, decl := range types {
		typedefs = append(typedefs, fmt.Sprintf("const %s = %s;", name, decl))
	}
	sort.Strings(typedefs)

	p.Println(`// required collection types`)
	for _, typedef := range typedefs {
		p.Println(typedef)
	}
}
