package golang

import (
	"fmt"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/mprot/mprotc/internal/gen"
	"github.com/mprot/mprotc/internal/schema"
)

// Options holds all the options for the Go language generator.
type Options struct {
	ImportRoot   string // root path of all schema imports
	ScopedEnums  bool   // scope enumerators?
	UnwrapUnions bool   // unwrap union types in struct fields?
	TypeID       bool   // generate TypeID method?
}

// Generator represents a code generator for the Go programming language.
type Generator struct {
	importRoot string
	cnst       constGenerator
	enum       enumGenerator
	strct      structGenerator
	union      unionGenerator
	service    serviceGenerator
}

// NewGenerator creates a new Go code generator with the given options.
func NewGenerator(opts Options) *Generator {
	return &Generator{
		importRoot: opts.ImportRoot,
		enum: enumGenerator{
			scoped: opts.ScopedEnums,
			typeid: opts.TypeID,
		},
		strct: structGenerator{
			unwrapUnion: opts.UnwrapUnions,
			typeid:      opts.TypeID,
		},
		union: unionGenerator{
			typeid: opts.TypeID,
		},
	}
}

// Generate generates the Go code for the given schema and prints it to p.
func (g *Generator) Generate(w *gen.FileWriter, s schema.Schema) {
	for _, file := range s {
		g.generate(w.Printer(file.Name, ".go"), file)
	}
}

func (g *Generator) generate(p gen.Printer, f *schema.File) {
	imports, importNames := g.goImports(f)
	hasService := containsService(f)

	p.Println(`// Code generated by mprotc.`)
	p.Println(`// Do not edit.`)
	p.Println()

	printDoc(p, f.Doc, "")
	p.Println(`package `, f.Package.Name)
	p.Println()
	p.Println(`import (`)
	if hasService {
		p.Println(`	"bytes"`)
		p.Println(`	"context"`)
	}
	p.Println(`	"fmt"`)
	p.Println(`	"time"`)
	p.Println()
	if hasService {
		p.Println(`	mrpc "github.com/mprot/mrpc-go"`)
	}
	p.Println(`	msgpack "github.com/mprot/msgpack-go"`)
	if len(imports) != 0 {
		p.Println()
		for _, imp := range imports {
			p.Println(`	`, imp.Name, ` "`, imp.Path, `"`)
		}
	}
	p.Println(`)`)
	p.Println()
	if hasService {
		p.Println(`var _ *bytes.Buffer`)
		p.Println(`var _ context.Context`)
	}
	p.Println(`var _ = fmt.Errorf`)
	p.Println(`var _ time.Time`)
	if hasService {
		p.Println(`var _ *mrpc.Server`)
	}
	p.Println(`var _ *msgpack.Writer`)

	ti := newTypeinfo(importNames)
	for _, decl := range f.Decls {
		p.Println()

		switch decl := decl.(type) {
		case *schema.Const:
			g.cnst.Generate(p, decl)
		case *schema.Enum:
			g.enum.Generate(p, decl, ti)
		case *schema.Struct:
			g.strct.Generate(p, decl, ti)
		case *schema.Union:
			g.union.Generate(p, decl, ti)
		case *schema.Service:
			g.service.Generate(p, decl, ti)
		default:
			panic(fmt.Sprintf("unsupported declaration type %T", decl))
		}
	}
}

func (g *Generator) goImports(f *schema.File) ([]schema.Import, map[string]string) {
	curdir := filepath.Dir(f.Name)
	imports := make([]schema.Import, 0, len(f.Imports))
	importNames := make(map[string]string, len(f.Imports)) // go name => mprot name
	for _, imp := range f.Imports {
		goimp := *imp

		goimp.Path = filepath.Dir(goimp.Path)
		goimp.Path = normalizePath(path.Join(g.importRoot, curdir, goimp.Path))

		rel := strings.TrimPrefix(goimp.Path, g.importRoot)
		rel = strings.TrimPrefix(rel, "/")
		if rel == "" {
			rel = "."
		}
		if rel == curdir {
			continue // exclude imports from same directory
		}

		goimp.Name = path.Base(goimp.Path)
		goimp.Name = strings.ReplaceAll(goimp.Name, "-", "_")

		imports = append(imports, goimp)
		importNames[imp.Name] = goimp.Name
	}

	sort.Slice(imports, func(i, j int) bool { return imports[i].Path < imports[j].Path })
	return imports, importNames
}

func normalizePath(path string) string {
	if filepath.Separator == '/' {
		return path
	}
	return strings.ReplaceAll(path, string(filepath.Separator), "/")
}

func containsService(f *schema.File) bool {
	for _, decl := range f.Decls {
		if _, ok := decl.(*schema.Service); ok {
			return true
		}
	}
	return false
}
